---
layout:     post   				    # 使用的布局（不需要改）
title:      关于Redis,MyBatis和Spring之中问题的一点梳理 	# 标题 
subtitle:   包括SpringBean,以及Lua脚本的一些杂谈                #副标题
date:       2019-11-8				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - Redis
    - MyBatis
    - Lua
---

最近在极限做项目的过程之中真的学到了很多……当然压力也真的很大,总是担心自己会成为团队的瓶颈,所以只能更逼自己去make it. 今天分配我的第一阶段的任务已经结束了,正好趁这个周五,马上要从北京回到坡县的晚上,在马上要去理发的间隙,静下心来好好梳理一下最近的收获和心得. 话不多说,开搞!

# 1. 关于 Redis 部分的总结

在新项目的过程之中,Redis的部分是我第一次遇到。 之前的，都只能算是“ 纸上谈兵”。 除了默认的配置文件之外，还有一些其他的地方需要注意。我也会在这个部分说一下程序之中的 .lua 脚本， 具体分析一下代码的作用。

在配置文件之中，其主要就是指定端口等等。

Redis 的默认端口是 6379。在配置文件之中，也可以指定数据库的数量（database），Redis使用不同的数据库，做一个不同应用数据之间的隔离。不同DB number 表示的数据库是隔离的。

Redis的使用非常简单，由于Redis 本身就是 Key-Value对，所以并不需要很多格外的数据格式匹配。下面主要讲一下在Spring Boot之中，对于Redis 全套，包括Redisconfig，  来做一个比较具体和有例子的总结和梳理。

## 1.1 Redis 的安装

下面以HomeBrew 的安装为例：

```shell
brew install redis
```

由于在设置之中我们的端口号使用的就是Redis 默认的端口号，因此在本次讲解之中无需对Redis 做过多的配置。可以直接启动Redis；

```
 redis-server
```

最简单的第一步就结束了。

## 1.2 RedisConfig 分析

### 1.2.1 @CompileStatic

@CompileStatic groovy 本身的一个 annotation， 作用是将代码静态编译，生成的字节码可以直接像 javac 的字节码一样，被快速运行。如果不想代码被静态编译，可以直接使用 @CompileStatic(SKIP) 可以通过指定的方法跳过静态编译，即使其 class 已经被标记为 @ComplieStatic。

同样的，类似于 javac 字节码，通过注解声明生成的字节码，和一般的 Groovy 的动态编程的字节码相比，生成的字节码会更小，因为为了 Groovy 的动态编程特性，字节码之中会包含一些指令供 Groovy Runtime System 调用。

### 1.2.2 @Configuration

@Configuration 是 Spring Boot 的 annotation。如果说的直白一点，这句 annotation 就是 Config 的一个开关。

下面对 SpringBean 做一个简要的介绍。

### 1.2.3 Spring @Bean

首先尝试在官网上面进行相关内容的查找，但是发现根本没有……只有对于 @Bean 的用法简介。那么也只能去别的地方查找一下都有什么样的资料了。

下文是通过 spring的依赖注入到底有什么优势？ - 大宽宽的回答 - 知乎 https://www.zhihu.com/question/27053548/answer/595191356 了解到的。做一点自己的理解和解释：

在OOP 之中，业务是通过不同 Object 之间相互通信来进行业务逻辑的设计和实现。但是这样做就不可避免的涉及到不同 Object 之间的调用。如果想调用某个Object 的方法， 那么就得拿到那个 Object 的引用。

在引用其他对象的时候，要针对系统本身的不同进行设计，有些对象可能整个系统之中只需要一个实例，有的可能每次都需要创建一个新的实例，介于两者之间，会有可能是某种“池化Object“ 的特定逻辑，比如连接池可能只可以有100个Connection Object。

对于不同的对象，我们也需要进行初始化，赋给资源，释放资源等等，这些都是属于对 Object 生命周期管理的逻辑。如果没有注入机制，这些逻辑就会在系统的每个角落都有，那么会带来巨大的维护问题。

> 工厂： 在OOP 之中， 工厂通常是一个用来创建其他对象的对象。工厂是构造方法的抽象，用来实现不同的分配方案。

那么一个更好的方法是，每一个Object 都可以定义自己的初始化静态工厂方法来完成初始化，都封装在里面，然后别的地方都调用这个方法。这种做法依然需要开发者**手动**将调用写出来。这种通过代码告诉编译器“我要XXX Object” 的方法，就被提取出来称作”静态依赖注入“。

**静态注入**

 静态注入的本质是，弄一个全局的大KV，Key 是那个 Object 的类，value 就是 new 出来的所有的 Object。 这个时候代码的逻辑就是：

1. 创建这个大KV
2. 手工new或者通过静态方法创建第一个没有任何依赖的Object，并记录到大KV里
3. 手工new或者通过静态方法创建其他Object，如果创建时需要依赖已经创建好的Object，就从KV里取出来直接用
4. 所有的Object都创建完了，服务就可以启动了

这种方式对于编写大型项目十分不友好。试想一下，在大型项目之中每次都先@Inject， 然后还要管理不同的顺序，是要写吐血的。

**动态注入**